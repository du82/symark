<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Content Graph | SyMark</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        .links line {
            stroke: #999;
            stroke-opacity: 0.6;
            transition: stroke 0.3s, stroke-opacity 0.3s;
        }

        .nodes circle {
            stroke: #fff;
            stroke-width: 1.5px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .node-label {
            font-size: 12px;
            pointer-events: none;
            font-weight: 500;
            text-shadow: 1px 1px 0 var(--background-color),
                        -1px 1px 0 var(--background-color),
                        1px -1px 0 var(--background-color),
                        -1px -1px 0 var(--background-color),
                        0px 1px 0 var(--background-color),
                        0px -1px 0 var(--background-color),
                        1px 0px 0 var(--background-color),
                        -1px 0px 0 var(--background-color);
            transition: all 0.3s ease;
        }

        .graph-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: none;
            margin: 0;
            background-color: var(--background-color);
            background-image: radial-gradient(circle, rgba(0,0,0,0.02) 1px, transparent 1px);
            background-size: 25px 25px;
        }



        .tooltip {
            position: absolute;
            background-color: var(--background-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px;
            font-size: 14px;
            max-width: 300px;
            pointer-events: none;
            z-index: 200;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            transform: translateY(10px);
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <header class="site-header">
        <div class="header-content">
            <a href="index.html" class="site-title">SyMark</a>
            <div class="header-icons">
                <a href="#" class="header-icon" title="Search">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
                </a>
                <a href="graph.html" class="header-icon" title="Content Graph">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="6" r="3"></circle>
                        <circle cx="6" cy="18" r="3"></circle>
                        <circle cx="18" cy="18" r="3"></circle>
                        <line x1="10.5" y1="8.5" x2="7.5" y2="15.5"></line>
                        <line x1="13.5" y1="8.5" x2="16.5" y2="15.5"></line>
                        <line x1="9" y1="18" x2="15" y2="18"></line>
                    </svg>
                </a>
            </div>
        </div>
    </header>

    <div class="graph-container" id="graph"></div>
    <div id="tooltip" class="tooltip"></div>
    


    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // Graph data will be populated by the generator
        const graphData = {"links":[{"source":"20250507101719-g6hylwe","target":"20250506183737-jh03nc2","value":1},{"source":"20250506164324-csw026m","target":"20250506183737-jh03nc2","value":1},{"source":"20250506164324-csw026m","target":"20250507101719-g6hylwe","value":1},{"source":"20250506164324-csw026m","target":"20250508102758-u01h899","value":1},{"source":"20250506164324-csw026m","target":"20250506230139-lnmadl3","value":1},{"source":"20250506164324-csw026m","target":"20250507135108-7plxwem","value":1},{"source":"20250506164324-csw026m","target":"20250507101913-9jo95mk","value":1},{"source":"20250506164324-csw026m","target":"20250615054852-jaujqy6","value":1},{"source":"20250506164324-csw026m","target":"20250616021259-6nf4yjv","value":1}],"nodes":[{"connections":2,"id":"20250506183737-jh03nc2","tags":[],"title":"How to use SyMark"},{"connections":1,"id":"20250506230139-lnmadl3","tags":["Features"],"title":"Themes"},{"connections":1,"id":"20250615054852-jaujqy6","tags":[],"title":"Design philosophy of SyMark"},{"connections":2,"id":"20250507101719-g6hylwe","tags":["Features"],"title":"Changelog"},{"connections":1,"id":"20250508102758-u01h899","tags":[],"title":"Benchmarks"},{"connections":0,"id":"20250507152346-lt7yop4","tags":[],"title":"Showcase"},{"connections":1,"id":"20250507101913-9jo95mk","tags":[],"title":"Build software to last"},{"connections":1,"id":"20250616021259-6nf4yjv","tags":[],"title":"How SyMark works"},{"connections":1,"id":"20250507135108-7plxwem","tags":["Features"],"title":"Templating"},{"connections":8,"id":"20250506164324-csw026m","tags":["index"],"title":"SyMark: Transform Your SiYuan Notes into Beautiful Websites"}]};

        // Map tags to colors - will be populated dynamically
        const tagColors = {"Features":"#4285F4"};

        // Get color for a node based on its tags
        function getNodeColor(d) {
            if (!d.tags || d.tags.length === 0) {
                return "#69b3a2"; // Default color
            }

            // Use the first tag that has a defined color
            for (const tag of d.tags) {
                if (tagColors[tag]) {
                    return tagColors[tag];
                }
            }

            // If no matching tag found, return default
            return "#69b3a2";
        }

        // Initialize the visualization
        function initGraph() {
            const width = document.getElementById('graph').clientWidth;
            const height = document.getElementById('graph').clientHeight;

            const svg = d3.select('#graph')
                .append('svg')
                .attr('width', width)
                .attr('height', height)
                .style('background', 'transparent');

            // Create a tooltip
            const tooltip = d3.select('#tooltip');

            // Create a container for the graph
            const g = svg.append('g');

            // Add zoom behavior
            svg.call(d3.zoom()
                .extent([[0, 0], [width, height]])
                .scaleExtent([0.1, 8])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                }));

            // Create the force simulation
            const nodeSizeMultiplier = 1;
            const simulation = d3.forceSimulation(graphData.nodes)
                .force('link', d3.forceLink(graphData.links).id(d => d.id).distance(200))
                .force('charge', d3.forceManyBody().strength(-350))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(d => (6 + Math.min(d.connections || 0, 10)) * 2))
                .alphaDecay(0.008) // Slower cooling for better stabilization
                .velocityDecay(0.3) // Add some friction to prevent excessive movement
                .alpha(0.3) // Set initial alpha
                .restart();

            // Draw the links
            const link = g.append('g')
                .attr('class', 'links')
                .selectAll('line')
                .data(graphData.links)
                .enter()
                .append('line')
                .attr('stroke-width', d => Math.sqrt(d.value || 1) * 1.5);

            // Draw the nodes
            const node = g.append('g')
                .attr('class', 'nodes')
                .selectAll('circle')
                .data(graphData.nodes)
                .enter()
                .append('circle')
                .attr('r', d => (6 + Math.min(d.connections || 0, 10)) * nodeSizeMultiplier)
                .attr('fill', getNodeColor)
                .attr('filter', 'drop-shadow(0 2px 3px rgba(0,0,0,0.2))')
                .attr('stroke-width', 2) // Slightly thicker stroke
                .attr('stroke', '#fff')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            // Add labels to nodes
            const label = g.append('g')
                .attr('class', 'node-labels')
                .selectAll('g')
                .data(graphData.nodes)
                .enter()
                .append('g')
                .attr('class', 'node-label-container');

            // No background rectangle needed since we're using text shadow

            // Add the text with better positioning
            label.append('text')
                .attr('class', 'node-label')
                .text(d => d.title || d.id)
                .attr('dx', 0)
                .attr('dy', 4)
                .attr('fill', 'var(--text-color)');

            // Node hover effects
            node.on('mouseover', function(event, d) {
                    const [x, y] = d3.pointer(event, document.body);
                    // Build tooltip content
                    let tooltipContent = `<strong>${d.title || d.id}</strong>`;

                    // Add tags if present
                    if (d.tags && d.tags.length > 0) {
                        tooltipContent += '<br><span style="font-size: 12px;">Tags: ';
                        d.tags.forEach((tag, i) => {
                            const color = tagColors[tag] || "#69b3a2";
                            tooltipContent += `<span style="display: inline-block; margin-right: 5px; padding: 2px 5px; background: ${color}; color: white; border-radius: 3px;">${tag}</span>`;
                        });
                        tooltipContent += '</span>';
                    }

                    // Add number of connections
                    tooltipContent += `<br>Connections: ${d.connections || 0}`;

                    tooltip.style('left', (x + 10) + 'px')
                           .style('top', (y + 10) + 'px')
                           .style('opacity', 0.95)
                           .style('transform', 'translateY(0)')
                           .html(tooltipContent);

                    // Highlight connections
                    link.style('stroke', l => (l.source.id === d.id || l.target.id === d.id) ? '#ff7700' : '#999')
                        .style('stroke-opacity', l => (l.source.id === d.id || l.target.id === d.id) ? 1 : 0.1)
                        .style('stroke-width', l => (l.source.id === d.id || l.target.id === d.id)
                            ? Math.sqrt(l.value || 1) * 2.5
                            : Math.sqrt(l.value || 1) * 1.5);

                    node.style('opacity', n => isConnected(d, n) ? 1 : 0.15)
                        .style('r', n => isConnected(d, n) && n.id === d.id
                            ? (6 + Math.min(n.connections || 0, 10)) * nodeSizeMultiplier * 1.5
                            : (6 + Math.min(n.connections || 0, 10)) * nodeSizeMultiplier);
                    
                    label.style('opacity', n => isConnected(d, n) ? 1 : 0.15)
                        .select('text')
                        .style('font-weight', n => n.id === d.id ? 'bold' : 'normal');
                    
                    // No background rectangle styling needed
                })
                .on('mouseout', function() {
                    tooltip.style('opacity', 0)
                           .style('transform', 'translateY(10px)');

                    // Reset highlights
                    link.style('stroke', '#999')
                        .style('stroke-opacity', 0.6)
                        .style('stroke-width', d => Math.sqrt(d.value || 1) * 1.5);

                    node.style('opacity', 1)
                        .style('r', d => (6 + Math.min(d.connections || 0, 10)) * nodeSizeMultiplier);
                    
                    label.style('opacity', 1)
                        .select('text')
                        .style('font-weight', 'normal');
                    
                    // No background rectangle reset needed
                })
                .on('click', function(event, d) {
                    window.location.href = d.id + '.html';
                });

            // Update the simulation on tick
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                // Position the label groups
                label.attr('transform', d => `translate(${d.x + 12}, ${d.y})`);
            });

            // Drag functions
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                // Keep the node fixed after dragging to prevent disconnection from links
                // We're explicitly setting fx and fy to the current position
                d.fx = d.x;
                d.fy = d.y;
            }

            // Check if two nodes are connected
            function isConnected(a, b) {
                if (a.id === b.id) return true;
                return graphData.links.some(l =>
                    (l.source.id === a.id && l.target.id === b.id) ||
                    (l.source.id === b.id && l.target.id === a.id)
                );
            }

            // Check if two nodes are connected
            function isConnected(a, b) {
                if (a.id === b.id) return true;
                return graphData.links.some(l =>
                    (l.source.id === a.id && l.target.id === b.id) ||
                    (l.source.id === b.id && l.target.id === a.id)
                );
            }
            
            // Fix all nodes after 3 seconds of simulation to prevent disconnections
            setTimeout(() => {
                graphData.nodes.forEach(d => {
                    d.fx = d.x;
                    d.fy = d.y;
                });
            }, 3000);
        }

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', initGraph);
    </script>
</body>
</html>
